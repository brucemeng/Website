---
title: Volatility of Revenue thoughts
author: Bruce Meng
date: '2017-10-28'
slug: volatility-of-profit-and-loss-thoughts
categories: []
tags:
  - R
  - statistics
---

```{r setup, include = FALSE}
library(ggplot2)
library(forecast)
library(magrittr)
set.seed = 1
```

I did this bit of analysis for BMO Investor Relations a few years back while I was with BMO Capital Markets but I think it is still an interesting topic.

The quick summary is that BMO Investor Relations received a published report, as well as the data and analysis underpinning the report from one of the credit rating agencies. The rating agency analyst made some certain assertions about BMO's revenue volatility, but it turns out that the statistical analysis used by the analyst was... questionable.

Before we get into that however, let's first define some terms and some concepts so that we are all on the same page. Let's start with... what is volatility?

## Volatility definition

To me, volatility is best defined as:

> Volatility is something unexpected happening...

So, for instance, the sun rises and sets every day. You can therefore say that the value changes from day to night constantly, but because the sun rising and setting is expected, this wouldn't be a cause for volatility. Indeed, if the opposite were to happen, then a unfathomable catastrophe would have instead occurred.

Now, let's introduce some data to move this discussion from a purely theoretical one. We shall use three companies to illustrate this:  

* Company A (A) - a linear trending series
* Company B (B) - a non-trending series
* Company C (C) - a random series, with no trend

```{r data.gen}
A <- c(100,110,120,130,140,150) %>% data.frame(Date = zoo::index(.), 
                                               Revenue = ., 
                                               Company = "A")

B <- c(125,125,125,125,125,125) %>% data.frame(Date = zoo::index(.), 
                                               Revenue = ., 
                                               Company = "B")

C <- runif(6, min = 100, max = 150) %>% data.frame(Date = zoo::index(.), 
                                                  Revenue = ., 
                                                  Company = "C")

company <- rbind(A, B, C)
```

Visualizing the above data points shows this:

```{r data.gen.visual, echo = T}
ggplot(company, aes(x = Date, y = Revenue)) +
        geom_line() +
        facet_grid(. ~ Company) +
        theme_minimal()
```

Intuitively, based on the above definition, we would conclude that Vol(A) = Vol(B) = 0, and Vol(C) > Vol(A) & Vol(B).

Using standard deviation as our quantitative measure of volatility, let's see what happens if we calculate the standard deviation of A, B, C directly:

```{r sd}
data.frame(A = round(sd(A$Revenue),0), 
           B = sd(B$Revenue), 
           C = round(sd(C$Revenue),0)) %>%
                knitr::kable()
```

The above result violates our intuitive understanding that Vol(A) = Vol(B), since the standard deviation of A is not the same as the standard deviation of B. This is because A is a trending series.

We need to transform our series of numbers to remove the trend. We can do this by first differencing all three companies (i.e. we look at the change in the original numbers for A, B, C).

```{r transform, warning=F}
# Transform data
A$Rev.transform <- c(NA, diff(A$Revenue))
B$Rev.transform <- c(NA, diff(B$Revenue))
C$Rev.transform <- c(NA, diff(C$Revenue))

company.transform <- rbind(A, B, C)

# Plot data
ggplot(company.transform, aes(x = Date, y = Rev.transform)) +
        geom_line() +
        facet_grid(. ~ Company) +
        ylab("Revenue Change") +
        theme_minimal()
```


The above graphs show that A has been increasing their results by 10 every year, B has no change to their results every year, and C has a variable change to their results every year.

Now, if we repeat our standard deviation calculation on the first differenced results, we will get a quantitative measure of volatility that doesn't violate our intuition.

```{r sd.transform}
data.frame(A = round(sd(A$Rev.transform, na.rm = T),0), 
           B = sd(B$Rev.transform, na.rm = T), 
           C = round(sd(C$Rev.transform, na.rm = T),0)) %>%
                knitr::kable()
```